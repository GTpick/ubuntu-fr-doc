{{tag>console shell}}
----

====== Le terminal GNU/Linux ======

Le terminal est un programme qui ouvre une [[console]] dans une interface graphique, il permet de lancer des **[[commande_shell|commandes]]**.

{{ ::terminal.png?direct&400 |Un terminal lancé sous Ubuntu 15.10}}

===== Pourquoi le terminal ? =====

Il est parfois plus simple de **taper une commande** que d'effectuer des manipulations demandant beaucoup de clics de souris dans une interface graphique. C'est aussi un moyen plus simple pour expliquer comment faire quelque chose à quelqu'un (sur un forum par exemple), puisque il suffit d'indiquer la commande et non la suite de clics à effectuer sur l'interface graphique.

Cependant, même si le terminal peut être beaucoup plus efficace qu'une interface graphique sous les doigts d'un utilisateur avancé, il est moins abordable que les interfaces graphiques.

Il est probable qu'aucune des deux méthodes (commandes ou interface graphique) ne remplacera complètement l'autre car elles se complètent plus qu'elles ne rivalisent.

===== Comment ouvrir un terminal ?=====
De manière générique, on ouvre le terminal avec la commande **x-terminal-emulator** (cette commande n'est qu'un lien sur votre terminal par défaut grace à **update-alternatives**)

Sinon, le tableau suivant donne les différentes méthodes qui permettent d'ouvrir le terminal:

^ Variante ^ Menu ^ Accès rapide ^ Raccourci clavier ^
^ [[:Ubuntu]] | Rechercher **terminal** | <Alt><F2> et tapez **gnome-terminal** | <CTRL><Alt><T> |
^ [[:Edubuntu]] | ::: | ::: | ::: |
^ [[:Lubuntu]] | //Menu -> Accessoires -> lxterminal// | | <CTRL><Alt><T> |
^ [[:Kubuntu]] | //K → Applications → Système → Konsole// | <Alt><F2> et tapez **konsole** | ajouter un raccourcis clavier avec l'adresse de l'application: /usr/share/applications/org.kde.konsole.desktop|
^ [[:Xubuntu]] | //Applications → Accessoires → Émulateur de Terminal// | <Alt><F2> et tapez **[[:xfterm4]]** (ou en fonction de la version **xfce4-terminal**) | <Super>((touche généralement représentée par le logo Windows)) <T> et <CTRL><Alt><T> |
^ [[:Cinnamon]] | Menu → Administration → Terminal | <Alt><F2> et taper **gnome-terminal** | <CTRL><Alt><T> |
===== Passer votre commande ! =====

L'utilisation est assez simple, tapez une commande (ou copiez-collez la) et faites //Entrée// (clavier) pour l'exécuter.

Les raccourcis pour le copier-coller ne sont pas Crtl+C ↔ Ctrl+V par défaut, mais **Maj+Ctrl+C** et **Maj+Ctrl+V**. En effet, dans un terminal le raccourci **Ctrl+C** annule la commande en cours. Cependant il est possible de modifier les raccourcis du Terminal (voir en bas de page la rubrique [[#personnaliser son terminal]]) mais c'est une opération qui présente des risques de conflits entre les raccourcis "de la console" et les raccourcis "du terminal"
<note tip>**[[wpfr>Complètement|Complétion automatique]]**\\
Après avoir tapé 2 ou 3 caractères, il est possible d'appuyer sur la touche //tab// qui permet de compléter la suite de la commande, du nom du dossier ou fichier. Cela évite les erreurs de frappe et est très appréciable pour éviter de saisir le nom de fichier parfois long et complexe comme le nom de certains paquets. Peut-être utilisé plusieurs fois si plusieurs noms ont une partie commune. \\
:!: Attention, [[wpfr>Sensibilité_à_la_casse|c'est sensible à la casse majuscules/minuscules des caractères]] ! </note>

===== Qu'est-ce qu'une commande ? =====

Une commande est une ligne de texte, sur la documentation elle apparaît souvent comme ça :
<code>
ma commande
</code>

Parfois, il y en a plusieurs de suite, comme ça :
<code>
sudo apt-get update 
sudo apt-get upgrade 
sudo apt-get install vlc-plugin-pulse mozilla-plugin-vlc libavcodec-extra-52
</code>

<note important>Attention lorsque vous copier coller des commandes dans un terminal bêtement elle risque d'être immédiatement exécutée sans taper Entrée.\\
C'est parce que le "caractère" Entrée est inclus si vous sélectionnez plusieurs lignes (faites l'essai avec les 2 premières du code ci-dessus ;-)). C'est pratique mais parfois dangereux (un rm copier trop vite par exemple) ! </note>

Une commande est pour ainsi dire un programme comme les autres. Par exemple pour ouvrir [[:Firefox]], vous pouvez taper :

<code>
firefox
</code>
  
dans un terminal.

===== Compléter une commande =====

Parfois sur un forum, ou dans une documentation, vous trouverez des commandes de ce genre :
<code>mv "le fichier à déplacer" "le dossier où le déplacer"</code>
<code>stella /vers/une/rom</code>
<code>gedit 'mon fichier.conf'</code>

De telles commandes sont des exemples types, et ne sont pas à recopier tel quel, mais doivent être adaptées à votre cas.

Dans un cas similaire au premier exemple : //mv "le fichier à déplacer" "le dossier où le déplacer"//, il suffit de taper le début de la commande : //mv//, puis //espace//, puis de faire un //glisser-déposer du fichier// de votre gestionnaire de fichier jusqu'au terminal, puis //espace//, un second //glisser-déposer//, puis //entrer// pour exécuter la commande.

Parfois ce ne sera pas un dossier ni un fichier qui vous sera demandé, dans ce cas, il vous sera sûrement expliqué comment connaître ce qu'il faut y mettre entre des guillemets, par exemple :
<code>
sudo adduser "votre pseudo" vboxusers
</code>

Ici il faut juste mettre votre pseudo à la place de **"votre pseudo"**.

===== Ma commande me demande mon mot de passe =====

"Je tape une commande, et je me retrouve face à quelque chose comme ceci:"
<code>
[sudo] password for Michel:
</code>
 
Après ceci vous devez taper votre mot de passe, ceci est tout à fait normal pour les commandes commençant par ``sudo`` comme:
<code>
sudo apt-get autoremove
</code>
  
"Mais voilà, mon mot de passe ne se tape pas !"

Tout à fait normal mon cher Michel, en fait le mot de passe est bel et bien tapé, mais vous ne le voyez pas, il suffit donc de taper son mot de passe, faire entrer et tout se déroulera comme prévu. Il s'agit d'une mesure de sécurité pour que les personnes regardant l'écran ne puissent pas deviner le nombre de caractères que contient le mot de passe.

<note important>Si vous devez saisir un chiffre, il est possible qu'il faille le saisir différemment, par exemple en utilisant les chiffres au dessus des lettres "a...p" avec SHIFT+Chiffre.( Pas le pavé numérique ) </note>

Un peu plus sérieusement, **[[:sudo]]** est une commande pouvant se mettre devant n'importe quelle autre commande. Son utilité est de donner à un autre programme l'autorisation de toucher au système. (installer un programme, enlever un programme, modifier un fichier texte de configuration, etc). \\
**[[:sudo]]** vous demandera donc votre mot de passe pour s'assurer d'être bien en face d'une personne ayant l'autorisation de pratiquer ce genre de tâches.


===== Quand les commandes me posent des questions... =====

Parfois une commande peut vous demander quelque chose, la réponse à donner est souvent très simple, voici quelques exemples :

  * À un moment, une commande stoppe et vous demande ça :
<code>
Souhaitez-vous continuer [O/n] ?
</code>

alors là c'est simple, **[O/n]** veut dire que vous pouvez répondre **o** ou **n** à la question, pour répondre **Oui** ou **Non**

__Pourquoi "**O**" est en majuscule ?__

Simplement parce que c'est le choix par défaut, ce qui veut dire que si vous ne tapez rien, et que vous faites « Entrée », il comprendra **O**. 

Si ça avait été **[o/N]** à la place, si vous aviez fait entrer directement sans taper **o** la commande aurait stoppé, il a donc pris en compte la réponse par défaut, **N**.

<note idee>En anglais vous auriez eu **[Y/n]** , certains programmes non encore traduits vous poseront parfois ce genre de questions.</note>

  * Autre exemple, une commande attend une réponse précise :
<code>
In which directory do you want to install the mime type icons ?
  [/usr/share/icons]
</code>

Dans cet exemple vous pouvez répondre de multiples choses, mais vous ne comprenez pas la question... heureusement il y a une réponse par défaut.

__Comment la reconnaître ?__

Eh bien, elle est entre crochets **[...]** il suffira donc de faire Entrée, sans rien taper comme réponse, pour utiliser cette réponse par défaut !

Bon ce n'est pas trop difficile, hein ;-)

===== Une sorte d'interface graphique dans le terminal !!! ??? =====

Vous tomberez parfois sur des sortes d'interfaces graphiques dans le terminal, qui sont des **[[wpfr>Environnement_en_mode_texte|environnements en mode texte]]**. Ils sont souvent bleu, moche, la souris ne fonctionne pas dedans... (ça devient rare), mais reste aisé malgré tout à prendre en main.

  * **__Exemple 1__**, une question à deux choix :
<code>
Outil de configuration des paquets


 ┌─────────────────────┤ Configuration de xserver-xorg ├─────────────────────┐
 │                                                                           │
 │ Utilisez cette option si vous voulez que le choix du type de serveur X    │
 │ et du module du pilote de votre carte vidéo soient automatiques. Si       │
 │ cette détection automatique échoue, vous devrez entrer ces informations   │
 │ vous-même. Si elle réussit, les questions de configuration suivantes      │
 │ seront préremplies.                                                       │
 │                                                                           │
 │ Si vous préférez choisir le serveur X et le pilote vous-même, ne          │
 │ choisissez pas cette option. Vous n'aurez toutefois pas à choisir le      │
 │ serveur X si un seul est disponible.                                      │
 │                                                                           │
 │ Faut-il essayer de détecter automatiquement votre carte vidéo ?           │
 │                                                                           │
 │                    <Oui>                       <Non>                      │
 │                                                                           │
 └───────────────────────────────────────────────────────────────────────────┘
</code>

là ce n'est pas compliqué, vous utilisez les flèches **Gauche** ← et → **Droite** de votre clavier pour choisir entre **Oui** ou **Non**, la réponse choisie, est en **Rouge**, et faire **Entrer**.

  * **__Exemple 2__**, une liste :

<code>
Outil de configuration des paquets

 ┌─────────────────────┤ Configuration de xserver-xorg ├─────────────────────┐
 │ Pour que l'interface graphique utilisateur du système X Window            │
 │ fonctionne convenablement, il est nécessaire de choisir un pilote de      │
 │ carte graphique pour le serveur X.                                        │
 │                                                                           │
 │ Les pilotes sont en général nommés d'après le nom du fabricant de la      │
 │ carte vidéo ou du circuit graphique ; le nom peut aussi faire référence   │
 │ à un modèle particulier ou à toute une famille de circuits.               │
 │                                                                           │
 │ Pilote de serveur X :                                                     │
 │                                                                           │
 │                              ark              ↑                           │
 │                              ati              ▮                           │
 │                              chips            ▒                           │
 │                              cirrus           ↓                           │
 │                                                                           │
 │                                                                           │
 │                                  <Ok>                                     │
 │                                                                           │
 └───────────────────────────────────────────────────────────────────────────┘
</code>

Là vous devez choisir quelque chose dans une liste. Vous choisissez avec les flèches **Haut** ↑ et ↓ **Bas**, une fois choisi, faites **Tab** (souvent une touche avec deux flèches ← et → l'une au dessus de l'autre : ↹), vous devez tomber sur **Ok** et faites **Entrer** pour "appuyer" sur **Ok**

  * **__Exemple 3__**, une sélection multiple...

<code>
Outil de configuration des paquets

 ┌─────────────────────┤ Configuration de xserver-xorg ├─────────────────────┐
 │ Il est conseillé de ne conserver que les résolutions utiles. Les          │
 │ supprimer toutes a le même effet que n'en supprimer aucune : le serveur   │
 │ X tentera dans tous les cas d'utiliser la résolution la plus haute        │
 │ possible.                                                                 │
 │                                                                           │
 │ Modes vidéo utilisés par le serveur X :                                   │
 │                                                                           │
 │    [ ] 1920x1440                                                      ↑   │
 │    [ ] 1920x1200                                                      ▮   │
 │    [ ] 1856x1392                                                      ▒   │
 │    [ ] 1792x1344                                                      ▒   │
 │    [*] 1680x1050                                                      ▒   │
 │    [ ] 1600x1200                                                      ▒   │
 │    [*] 1440x900                                                       ↓   │
 │                                                                           │
 │                                                                           │
 │                                  <Ok>                                     │
 │                                                                           │
 └───────────────────────────────────────────────────────────────────────────┘

</code>

là vous devez choisir plusieurs choses, déplacez-vous sur un choix avec **Haut** et **Bas**, et faites **Espace** sur une case à cocher, ([*] Coché, [ ] décoché), une fois que tout ce que vous voulez cocher est coché, faites **Tab** et une fois arrivé sur **Ok**, faites **Entrer**

Voilà, vous connaissez à peu près tout ce que l'on peut rencontrer comme cas de figures dans les "//interfaces graphiques en lignes de commande//".

Une commande parfois répond, et parfois, ne dit rien… Pour comprendre pourquoi ce comportement est normal, une petite explication s'impose.

==== Les commandes peu bavardes ====

Les commandes comme **cd , mv , cp , ls , rm** et sûrement bien d'autres, sont des commandes de gestion de fichiers et de dossiers ; elles ne répondent qu'en cas d'erreur ! Elles remplacent en quelque sorte votre navigateur de fichiers, mais dans un terminal…

Pour comprendre pourquoi elles ne répondent pas, une petite comparaison entre ces commandes et un navigateur de fichiers peut être pratique.

Si la commande confirmait à chaque création de fichier, qu'elle a réussi à faire le fichier… Ce serait un peu comme si vous faisiez un copier-coller, et que l'on vous dise, dans une belle fenêtre, "Votre fichier a bien été copié-collé dans cet emplacement"... \\
Admettons que ce serait une perte de temps, et que signaler seulement les erreurs est bien plus utile...

==== Les commandes très bavardes… ====

Certaines commandes sont très bavardes ; prenons un exemple :

<code>sudo apt-get update</code>

Cette commande permet de mettre à jour la liste des paquets disponibles dans vos [[:dépôts]] tout ceci en lignes de commande, quand vous l'exécutez, elle aura la très bonne idée de dire tout ce qu'elle fait... oui, vous pouvez dire que ce n'est pas très utile, et que signaler seulement les erreurs serait plus intelligent aussi dans ce cas… \\
Mais en fin de compte non, car ce n'est pas comme copier un fichier, qui est un processus quasi instantané, là cette commande charge les index à partir d'internet, ce qui peut être long, si les serveurs sont surchargés ou autre. Donc pour ne pas inquiéter l'utilisateur, tout le long du processus est indiqué ce qu'il fait, pour comparer avec une interface graphique, c'est comme la barre de progression et les détails qui sont souvent affichés en dessous, c'est le même principe mais en moins beau.

==== Avec toutes ces informations comment repérer s'il y a eu une erreur ? ====

Si une commande ne marche pas, vous devez avoir un message contenant le mot **error**.

Si vous avez un message contenant le mot **warning** ignorez-le, il indique souvent des informations qui ne servent qu'aux développeurs, ou montre des petits détails, qu'il n'est pas vraiment indispensable de corriger !

En cas de doute, tapez la commande suivante, qui retourne le code de sortie de la commande précédente : 
<code>
echo $?
</code>

Si le code est '0', alors tout s'est bien passé (a condition que la commande appelée précédemment soit bien conçue et suive la convention classique). À noter que si vous répétez à nouveau cette commande, le code affiché sera bien celui de la commande précédente, à savoir la première commande "echo" que vous avez tapée. 

**Explication :** conventionnellement, un programme qui retourne une erreur va renvoyer un code d'erreur non nul, et **echo $?** retournera donc 1, 2 ou n'importe quel nombre non nul (généralement positif). Si vous retapez à nouveau **echo $?**, l'information retournée sera 0, car en effet l'echo retournant précédemment une erreur s'est lui même parfaitement bien déroulé !

===== Comment savoir à quoi sert une commande ? =====

Il suffit de taper 
<code>man commande</code>
Par exemple:
<code>
man iconv
man rm
man bash
man firefox
</code>

Tous les programmes ont des "man": ce sont les pages de [[:man|manuel]] de la commande. Parfois même des fichiers de configuration ont des pages de manuel ! \\
Pour sortir d'une page de manuel, il faut utiliser la touche **q**.

Pour connaître les principales commandes, voir cette page : [[:console#premiers_exemples|Utilisez une console, quelques exemples de commandes.]]

===== Quels sont tous les programmes utilisant la ligne de commande ? =====

Vous pouvez voir la [[:liste des applications console]] si vous voulez satisfaire votre curiosité en matière de commandes. Vous verrez que les logiciels y fonctionnant exclusivement ou ayant une version sans GUI y sont nombreux !

===== L'historique des commandes =====

Pour ré exécuter une commande déjà effectuée, au lieu de tout retaper, il vous suffit simplement d'appuyer sur la touche ↑ (flèche haut) pour accéder à la commande précédente.

Vous pouvez appuyer plusieurs fois sur ↑ pour aller plus loin dans l'historique ou taper la commande
<code>history</code>
Cette commande liste les 500 dernières commandes plus celles de la session actuelle. Elle retourne quelque chose de ce type :
<code>
(489 lignes masquées...)
  490  eject /dev/sr0
  491  history 
  492  sudo apt-get update && sudo apt-get dist-upgrade && sudo apt-get clean && sudo apt-get autoremove
  493  mount
  494  sudo mount /data/Véronique/
  495  cat /etc/exports 
  496  ls -l /data/
  497  touch /data/essai-Michel
  498  ls -l /data/
  499  ping -c 3 asus
  500  mount
  501  history 
</code>
Si vous souhaiter relancer la commande numéro 492, au lieu de la retaper, il suffit de lancer cette commande :
<code>!492</code>

Vous pouvez également rechercher une commande précédemment tapée. Commencer par taper <ctrl>+r. Tapez ensuite les premières lettres de la commande recherchée, et la recherche se met à jour au fur et à mesure. 
<code>
(reverse-i-search)`apt': sudo apt-get install kmymoney2 
</code>

Vous pouvez alors appuyer à nouveau sur <ctrl>+r afin de sélectionner un résultat plus ancien. Enfin, tapez ENTER pour valider, ou <ctrl>+g pour annuler.
Il est également possible de vider cet historique en utilisant la commande suivante:
<code>history -c</code>
Il est possible aussi de ne supprimer qu'une ligne (par exemple un mount avec un mot de passe admin!), pour cela utiliser l'option -d suivit du n° de ligne
<code>history -d 494</code>
supprime la ligne //sudo mount /data/Véronique/// dans la liste ci-dessus.

En ajoutant 
<code>HISTCONTROL=ignorespace</code> dans le .bashrc 
ou
<code>setopt HIST_IGNORE_SPACE</code> dans le .zshrc 

toute commande débutant avec un espace en début de ligne n'apparaîtra pas dans l'historique. 
=====Pour compléter les commandes à partir de l'historique :=====
Vous le savez certainement, toutes les commandes que vous utilisez dans un terminal sont archivées et vous pouvez y accéder par ordre chronologique en appuyant sur les touches fléchées Haut ou Bas. La fonctionnalité de base se limite à cela. Mais on peut faire beaucoup mieux et beaucoup plus pratique. Si vous voulez retrouver une commande particulière tapée il y a un moment. Prenons pour exemple ...  « rm /home/user/fichier.ext » !
Vous êtes obligés de taper Haut jusqu'à ce que vous tombiez dessus, et cela peut parfois être assez long — suffisamment long pour qu'il soit plus rapide de taper la commande intégralement.

**Grâce à la manipulation ci-dessous, vous n'aurez qu'à taper le début de la commande, par exemple « rm » et à presser la touche Haut. Une recherche sera faite dans l'historique et on vous affichera directement la bonne réponse !**
Alors voici comment procéder :

Dans votre fichier **~/.inputrc**, ajoutez à la fin : 
<file bash>
"\e[A": history-search-backward
"\e[B": history-search-forward
</file>
Dans votre fichier **~/.bashrc**, ajoutez à la fin :
<file bash>
shopt -s histappend
PROMPT_COMMAND='history -a'
</file>
Relancez votre terminal. Et essayez !
Pratique, non ? 

Vous pouvez également modifier graphiquement l'historique. Par exemple si vous avez copié un texte très long par erreur dans votre terminal. Pour cela modifier le fichier **.bash_history** et supprimez les lignes que vous souhaitez.

===== Du fun pour le terminal de geek =====

  * Regarder un remake de star wars un nouvel espoir en ascii : <code>telnet towel.blinkenlights.nl</code>
  * Les petits fun laissés par les développeurs : (appelé [[wp>Easter_egg_%28media%29|easter egg]])<code>apt-get moo</code><code>
aptitude moo

aptitude -v moo

aptitude -vv moo

aptitude -vvv moo

aptitude -vvvv moo

aptitude -vvvvv moo

aptitude -vvvvvv moo
</code>

  * Avoir un fond d'écran matrix dans la console avec [[apt>cmatrix|cmatrix]].

  * Affiche un train dans votre terminal en [[:tutoriel:comment_installer_un_paquet|installant]] **[[ apt>sl]]** et en le lançant avec:<code>
sl</code>

<note>Ceux qui suivent ne semblent plus fonctionner (Ubuntu 14.04)</note>
FIXME <code>tar -cvf toto/</code>
FIXME <code>checking for beer in -lfridge... no</code>
FIXME  <code>zgrep "The.*Release" /usr/share/doc/dpkg/changelog.Debian.gz</code>
  * FIXME Chatter avec un Bot : <code>telnet the-funk.net 7000 </code>

===== En savoir plus sur la console =====

La console est en quelque sorte ce que fait tourner un terminal, la console existe en mode texte « total » c'est-à-dire que sur votre écran, vous avez juste ce qui est à l'intérieur d'un terminal…

Pour en savoir plus sur la console, voir cette page : [[console]].

===== Personnaliser son terminal =====

==== Configurer les raccourcis clavier ====

Lancer un Terminal, dans //Édition -> Raccourcis clavier//, puis changer les raccourcis comme vous le souhaitez.

<note important>Les raccourcis Ctrl+[lettre] sont en général utilisés par le [[shell]], il est donc déconseillé de les utiliser pour les raccourcis du terminal.</note>

==== Configurer l'interface ====
Aller dans le menu //Édition -> Préférences du profil//.

=== Les couleurs ===
  * Mettre les palettes prédéfinie sur //Personnalisée//, puis
  * Choisir vos couleurs, nous conseillons du clair (blanc ou gris coloré) pour la couleur de texte et noir (noir coloré) pour la couleur d'arrière plan.
  * pour modifier la couleur de votre invite de commande lors du passage en super utilisateur, éditez le ficher **/etc/bash.bashrc** :
modifiez la ligne
<file bash>PS1='....' </file>
en
<file bash>
if [ `whoami` = root ]; then
      PS1='${debian_chroot:+($debian_chroot)}\[\033[01;31m\]\u@\h\[\033[00m\]:\[\033[01;34m\]\w\[\033[00m\]\$ '
      else
      PS1='${debian_chroot:+($debian_chroot)}\[\033[01;32m\]\u@\h\[\033[00m\]:\[\033[01;34m\]\w\[\033[00m\]\$ '
      fi
</file>

L'invite de commande super utilisateur s'affiche alors sous la forme [utilisateur] en rouge suivi de [chemin d'accès courant] en bleu au redémarrage du Terminal.

=== L'arrière-plan ===
  * Nous conseillons par exemple de mettre la transparence (ombrage transparent) vers la droite (soit environ 8/10<sup>ème</sup>, 80 % de transparence). Vous pourrez ainsi garder un œil sur ce qui se passe derrière le Terminal.

==== Un logo à l'ouverture du terminal ====

{{ :terminal:term_logo.png | }}

Si linuxlogo n'est pas installé, installez-le : [[apt>linuxlogo]]
<code>sudo apt-get install linuxlogo</code>

Ouvrez un terminal et entrez : ''**linuxlogo -L list**'' pour avoir la liste des logos disponibles.
Ce que j'obtiens avec la version 16.04 LTS :
<code>
Available Built-in Logos:
	Num	Type	Ascii	Name		Description
	1	Classic	Yes	aix		AIX Logo
	2	Classic	Yes	bsd		FreeBSD Logo
	3	Banner	Yes	bsd_banner	FreeBSD Logo
	4	Classic	Yes	irix		Irix Logo
	5	Classic	Yes	openbsd		OpenBSD Logo
	6	Banner	Yes	openbsd_banner	OpenBSD Logo
	7	Banner	Yes	solaris		The Default Banner Logos
	8	Banner	Yes	banner-simp	Simplified Banner Logo
	9	Banner	Yes	banner		The Default Banner Logo
	10	Classic	Yes	classic-nodots	The Classic Logo, No Periods
	11	Classic	Yes	classic-simp	Classic No Dots Or Letters
	12	Classic	Yes	classic		The Default Classic Logo
	13	Classic	Yes	core		Core Linux Logo
	14	Banner	Yes	debian_banner_2	Debian Banner 2
	15	Banner	Yes	debian_banner	Debian Banner (white) 
	16	Classic	Yes	debian_old	Debian Old Penguin Logos 
	17	Classic	Yes	debian		Debian Swirl Logos
	18	Classic	Yes	gnu_linux	Classic GNU/Linux
	19	Banner	Yes	mandrake_banner	Mandrake(TM) Linux Banner
	20	Banner	Yes	mandrake	Mandrakelinux(TM) Banner
	21	Banner	Yes	mandriva	Mandriva(TM) Linux Banner
	22	Banner	Yes	pld		PLD Linux banner
	23	Classic	Yes	raspi		An ASCII Raspberry Pi logo
	24	Banner	Yes	redhat		RedHat Banner (white) 
	25	Banner	Yes	slackware	Slackware Logo
	26	Banner	Yes	sme		SME Server Banner Logo
	27	Banner	Yes	sourcemage_ban	Source Mage GNU/Linux banner
	28	Banner	Yes	sourcemage	Source Mage GNU/Linux large
	29	Banner	Yes	suse		SUSE Logo
	30	Banner	Yes	ubuntu		Ubuntu Logo
</code>

Testez les différents logos en entrant ceci : 
<code> linuxlogo -L 9</code>
(équivaut aussi à **''linuxlogo -L classic-simp''**, celui de la capture écran ci-dessus)

Un fois que vous avez choisi votre logo [[:tutoriel:comment_modifier_un_fichier|modifiez le fichier]] **/etc/linux_logo.conf**

À la fin du fichier vous trouverez ceci : ''**-L debian**'', remplacez //debian// par le nom ou le numéro du logo que vous avez choisi.

Pour finaliser le tout, afin que le logo s'affiche au démarrage de votre terminal, [[:tutoriel:comment_modifier_un_fichier|éditez votre fichier]] **~/.bashrc**
À la fin de votre fichier ajoutez la ligne (après les alias normalement)
<file>linuxlogo -L ***le numéro du logo choisi***</file>

Et voilà, complètement inutile, mais geekement indispensable !

==== Un terminal sur le bureau ====

Beaucoup de personnes souhaitent avoir un terminal disponible sur le bureau, voilà l'astuce.

=== Installation ===
Tout d'abord il faut installer les paquets [[apt>xfce4-terminal|xfce4-terminal]] et [[apt>devilspie|devilspie]], le premier est un terminal, le second permet de définir le comportement des fenêtres, pour en savoir plus, voir cette page : [[devilspie]].

=== Paramétrage ===
Il est possible de lancer ce nouveau terminal via //Applications → Accessoires → Terminal//. Dans les préférences, il faut désactiver la barre de défilement (//Préférences → Général//), demander à ne pas afficher les bords de la fenêtre et définir l'arrière comme transparent (//Préférences → Aspect//).

A présent, il faut paramétrer devilspie. Pour cela, il faut créer un dossier **.devilspie** dans le dossier utilisateur
<code>
mkdir ~/.devilspie
</code>
et y créer un fichier intitulé : **xfce4-terminal.ds**.
<code>gedit ~/.devilspie/xfce4-terminal.ds</code>

Il faut créer la règle qui paramètre xfce4-terminal:
<file bash>
(if (is (window_class) "Xfce4-terminal") 
(begin 
(below)
(skip_tasklist)
(skip_pager)
(wintype "dock")
))
</file>
  * below : Permet de mettre la fenêtre en dessous de toutes les autres.
  * skip_tasklist : N'affiche pas la fenêtre dans la barre de tâches
  * skip_pager : Ne permet de sélectionner la fenêtre via le pager (**Alt + Tab**)
  * wintype : Permet de ne pas réduire la fenêtre lorsque l'on demande à afficher le bureau (bouton généralement en bas à gauche)

Cela fait, il ne reste plus qu'à lancer **devilspie** et **xcfe4-terminal** au démarrage. Dans //Système → Préférences → Sessions//, il faut ajouter deux commandes :
<file>devilspie –a</file>
**-a** permet d'appliquer les règles aux fenêtres déjà ouvertes
<file>xfce4-terminal --geometry=LARGEURxHAUTEUR+X+Y</file>
où LARGEUR et HAUTEUR sont exprimées en caractère de terminal, X et Y représente les coordonnées du point supérieur gauche du terminal. Pour donner une idée chez moi la commande est :
<file>xfce4-terminal --geometry=62x40+650+30</file>


<note tip>Avant d'ajouter les commande au démarrage, faites les tests à partir d'un terminal, surtout en ce qui concerne la géométrie du terminal sur le bureau.</note>

===== Pages concernant le terminal =====
Ici vous trouverez quelques pages pointant sur des astuces ou approfondissements de certaines commandes.\\
Vous y trouverez également différentes pages de présentation d'autres terminaux. Ne restez pas forcément figé sur celui installé par défaut pour vous faire une idée de la valeur de chacun. En effet certains ont des fonctionnalités que d'autres n'ont pas (par exemple le multifenêtrage)
{{topic>terminal}}
===== Voir aussi =====

  * [[https://launchpad.net/clicompanion|CLI Companion]] est un terminal qui vous permet de stocker et de commander votre «dictionnaire de commande.((N'oubliez pas la commande man pour connaitre les autres commandes.)) FIXME plus développé?
  * [[http://finalterm.org/|Final Term]] un terminal moderne disposant d'une complétion des commandes très efficace. FIXME développement arrêté
  * [[http://www.tuxradar.com/content/linux-tips-every-geek-should-know|Astuce que tous geek Linux devraient connaitre]](en). 
  * [[http://www.tuxradar.com/content/more-linux-tips-every-geek-should-know|Un peu plus d'astuce que tous les geek Linux devraient connaitre]](en)
  * [[http://www.howtogeek.com/howto/linux/stupid-geek-tricks-watch-movies-in-your-linux-terminal-window/|Astuce Geek Inutile: Regarder un film en ASCII dans son terminal]](en)
  * [[http://www.pixelbeat.org/cmdline.html|Memo de commandes Linux]](en)
  * [[http://ressources.tutoriels-video.fr/Ubuntu/Ubuntu-pour-les-debutants/tuto-concole/| Formation Vidéo de base pour les commandes]]

----
//Contributeurs: [[utilisateurs:Fabien26]], [[utilisateurs:1h0ma5]], [[utilisateurs:eagle08]].//

